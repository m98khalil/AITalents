---
title: "AITalents"
author: "Mostafa Khalil"
date: "11/18/2020"
output: html_document
---

```{r, echo=FALSE}

#Import libraries
 library(tidyr)
 library(dplyr)
 library(lubridate)
 library(caret)
 library(e1071)


#import datasets of messages that are generated by employees or from different devices in retail shops. It includes timestamps, locations, action identificators, texts and many other attributes. Each dataset is for a different calender week

setwd("~/Desktop/AITalents/messaging-KW-38-44")

KW_38<-read.csv("msg 2020-KW-38.csv")
KW_39<-read.csv("msg 2020-KW-39.csv")
KW_40<-read.csv("msg 2020-KW-40.csv")
KW_41<-read.csv("msg 2020-KW-41.csv")
KW_42<-read.csv("msg 2020-KW-42.csv")
KW_43<-read.csv("msg 2020-KW-43.csv")
KW_44<-read.csv("msg 2020-KW-44.csv")

#Data Cleaning and Preparation#
##################################

 #Datasets of calender week 43 & 44 have to extra rows, which have to be removed in order to  combine all datasets
 
KW_43<-subset(KW_43,select=-issueId)
KW_44<-subset(KW_44,select=-issueId)
total <- rbind(KW_38,KW_39,KW_40,KW_41,KW_42,KW_43,KW_44)
head(total)
 
```

```{r, echo=FALSE}
 #Seperate the recipient.roleName column, so that every row has only one role and unify the format of all strings
total_seperated_roles<- total %>% separate_rows(recipient.roleName, sep=",")
total_seperated_roles$recipient.roleName<-gsub("\\[|\\]", "", total_seperated_roles$recipient.roleName)
 
 #Select relevant columns for analysis and filter to include only one retail shop location
total_seperated_roles_subset<-subset(total_seperated_roles,select =   c(time.dayOfWeek,time.hourOfDay,recipient.roleName,location,X.timestamp))
total_seperated_roles_subset_1013 <- total_seperated_roles_subset [total_seperated_roles_subset$location==1013,]
 
 #Omit the rows with NA values, where the time or date is missing and the rows where no recipient.roleName is given
total_seperated_roles_subset_1013_na <- na.omit(total_seperated_roles_subset_1013)
total_seperated_roles_subset_1013_na<-total_seperated_roles_subset_1013[!(total_seperated_roles_subset_1013$recipient.roleName==""),]
 
 #Convert the X.timestamp column to a date and time variable and omit rows, where the conversion failed
total_seperated_roles_subset_1013_na$X.timestamp<-dmy_hms(total_seperated_roles_subset_1013_na$X.timestamp)
total_seperated_roles_subset_1013_na<-na.omit(total_seperated_roles_subset_1013_na)
 
 #Removing duplicate rows: Some messages are sent multiple times successively, e.g. to make the employee hurry up or to realert him if he doesn't see the first message.Only one of theses messages will be kept in the dataset. 
total_seperated_roles_subset_1013_na_grouped<- total_seperated_roles_subset_1013_na %>% group_by(yday(total_seperated_roles_subset_1013_na$X.timestamp)) %>% distinct(time.dayOfWeek,time.hourOfDay,recipient.roleName) 

 #Choosing specific recipient roles for analysis
chosen_recipient_roles<-total_seperated_roles_subset_1013_na_grouped %>% filter(recipient.roleName %in% c('"Backshop"','"Warenannahme"','"Wein Klingel"'))
 
 #wide format
chosen_recipient_roles_wide<-chosen_recipient_roles %>% mutate(Backshop_true=recipient.roleName=='"Backshop"', Warenannahme_true=recipient.roleName=='"Warenannahme"',Weinklingel_true=recipient.roleName=='"Wein Klingel"')
 
 #final dataset shape
data<-chosen_recipient_roles_wide[,-c(3,4)]

 #alternative time.hourofDay format
dat <- data %>%
    mutate(time.hourOfDay = case_when(
        time.hourOfDay < 10 & time.hourOfDay>= 6  ~ "morgen",
        time.hourOfDay >= 10 & time.hourOfDay < 12 ~ "vormittag",
        time.hourOfDay >= 12 & time.hourOfDay <= 13 ~ "mittag",
        time.hourOfDay >= 13 & time.hourOfDay < 17 ~ "nachmittag", time.hourOfDay >= 17 & time.hourOfDay < 24 ~ "abend", time.hourOfDay >= 0 & time.hourOfDay < 6 ~ "nacht"
        ))

head(dat)

```


```{r, echo=FALSE}

#Prediction model#
##################

split_index <- createDataPartition(dat$time.dayOfWeek, p=0.8, list=FALSE)
test <- dat[-split_index,]
train <- dat[split_index,]
 
nb_Backshop <- naiveBayes(as.factor(train$Backshop_true) ~ time.dayOfWeek+time.hourOfDay, data=train, laplace=1)
nb_Warenannahme <- naiveBayes(as.factor(train$Warenannahme_true) ~ time.dayOfWeek+time.hourOfDay, data=train, laplace=1)
nb_Weinklingel <- naiveBayes(as.factor(train$Weinklingel_true) ~ time.dayOfWeek+time.hourOfDay, data=train, laplace=1)

predictions_Backshop = predict(nb_Backshop, test, type="class")
predictions_Warenannahme = predict(nb_Warenannahme, test, type="class")
predictions_Weinklingel = predict(nb_Weinklingel, test, type="class")
 
cm_Backshop <- table(test$Backshop_true, predictions_Backshop) 
cm_Warenannahme <- table(test$Warenannahme_true, predictions_Warenannahme) 
cm_Weinklingel<-table(test$Weinklingel_true, predictions_Weinklingel) 

confusionMatrix(cm_Backshop)
confusionMatrix(cm_Warenannahme)
confusionMatrix(cm_Weinklingel)

```

```{r, echo=FALSE}
#Model Output for RShiny WebApp#
################################

week_days<-c("Samstag", "Montag","Dienstag","Mittwoch","Donnerstag","Freitag")
time_of_day<-c("morgen","vormittag","mittag","nachmittag","abend","nacht")
calender<-expand.grid(week_days,time_of_day)
colnames(calender)[1]<-"time.dayOfWeek"
colnames(calender)[2]<-"time.hourOfDay"

predictions_Weinklingel = predict(nb_Weinklingel, calender, type="class")
predictions_Backshop = predict(nb_Backshop, calender, type="class")
predictions_Warenannahme = predict(nb_Warenannahme, calender, type="class")

Weinklingel_results<-cbind(calender,predictions_Weinklingel)
Weinklingel_results_Sa<-Weinklingel_results[Weinklingel_results$time.dayOfWeek=="Samstag",c(2,3)]
Weinklingel_results_Mo<-Weinklingel_results[Weinklingel_results$time.dayOfWeek=="Montag",c(2,3)]
Weinklingel_results_Di<-Weinklingel_results[Weinklingel_results$time.dayOfWeek=="Dienstag",c(2,3)]
Weinklingel_results_Mi<-Weinklingel_results[Weinklingel_results$time.dayOfWeek=="Mittwoch",c(2,3)]
Weinklingel_results_Do<-Weinklingel_results[Weinklingel_results$time.dayOfWeek=="Donnerstag",c(2,3)]
Weinklingel_results_Fr<-Weinklingel_results[Weinklingel_results$time.dayOfWeek=="Freitag",c(2,3)]

Backshop_results<-cbind(calender,predictions_Backshop)
Backshop_results_Sa<-Backshop_results[Backshop_results$time.dayOfWeek=="Samstag",c(2,3)]
Backshop_results_Mo<-Backshop_results[Backshop_results$time.dayOfWeek=="Montag",c(2,3)]
Backshop_results_Di<-Backshop_results[Backshop_results$time.dayOfWeek=="Dienstag",c(2,3)]
Backshop_results_Mi<-Backshop_results[Backshop_results$time.dayOfWeek=="Mittwoch",c(2,3)]
Backshop_results_Do<-Backshop_results[Backshop_results$time.dayOfWeek=="Donnerstag",c(2,3)]
Backshop_results_Fr<-Backshop_results[Backshop_results$time.dayOfWeek=="Freitag",c(2,3)]

Warenannahme_results<-cbind(calender,predictions_Warenannahme)
Warenannahme_results_Sa<-Warenannahme_results[Warenannahme_results$time.dayOfWeek=="Samstag",c(2,3)]
Warenannahme_results_Mo<-Warenannahme_results[Warenannahme_results$time.dayOfWeek=="Montag",c(2,3)]
Warenannahme_results_Di<-Warenannahme_results[Warenannahme_results$time.dayOfWeek=="Dienstag",c(2,3)]
Warenannahme_results_Mi<-Warenannahme_results[Warenannahme_results$time.dayOfWeek=="Mittwoch",c(2,3)]
Warenannahme_results_Do<-Warenannahme_results[Warenannahme_results$time.dayOfWeek=="Donnerstag",c(2,3)]
Warenannahme_results_Fr<-Warenannahme_results[Warenannahme_results$time.dayOfWeek=="Freitag",c(2,3)]

Montag<-cbind(Warenannahme_results_Mo,Weinklingel_results_Mo,Backshop_results_Mo)[,-c(3,5)]
Dienstag<-cbind(Warenannahme_results_Di,Weinklingel_results_Di,Backshop_results_Di)[,-c(3,5)]
Mittwoch<-cbind(Warenannahme_results_Mi,Weinklingel_results_Mi,Backshop_results_Mi)[,-c(3,5)]
Donnerstag<-cbind(Warenannahme_results_Do,Weinklingel_results_Do,Backshop_results_Do)[,-c(3,5)]
Freitag<-cbind(Warenannahme_results_Fr,Weinklingel_results_Fr,Backshop_results_Fr)[,-c(3,5)]
Samstag<-cbind(Warenannahme_results_Sa,Weinklingel_results_Sa,Backshop_results_Sa)[,-c(3,5)]

```



